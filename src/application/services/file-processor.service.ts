/**
 * Application service for processing individual Markdown files
 * Coordinates the complete workflow from Markdown to PDF
 */

import * as path from 'path';

import { AnchorLinksGenerator } from '../../core/anchor-links/anchor-links-generator';
import { AnchorLinksDepth } from '../../core/anchor-links/types';
import { PDFGeneratorOptions, PDFGenerationResult } from '../../core/pdf/types';
import { TOCGeneratorOptions } from '../../core/toc/types';
import {
  MD2PDFError,
  FileNotFoundError,
} from '../../infrastructure/error/errors';
import { ParsedMarkdown, TOCReturnLinkLevel } from '../../types/index';
import { ImagePathResolver } from '../../utils/image-path-resolver';

import { IMarkdownParserService } from './markdown-parser.service';
import { IPDFGeneratorService } from './pdf-generator.service';

import type { IConfigManager } from '../../infrastructure/config/types';
import type { IErrorHandler } from '../../infrastructure/error/types';
import type { IFileSystemManager } from '../../infrastructure/filesystem/types';
import type { ITranslationManager } from '../../infrastructure/i18n/types';
import type { ILogger } from '../../infrastructure/logging/types';

export interface FileProcessingOptions {
  outputPath?: string;
  includeTOC?: boolean;
  includePageNumbers?: boolean;
  tocReturnLinksLevel?: TOCReturnLinkLevel;
  tocOptions?: Partial<TOCGeneratorOptions>;
  pdfOptions?: Partial<PDFGeneratorOptions>;
  customStyles?: string;
}

export interface FileProcessingResult {
  inputPath: string;
  outputPath: string;
  success: boolean;
  parsedContent: ParsedMarkdown;
  pdfResult: PDFGenerationResult;
  processingTime: number;
  fileSize: number;
}

export interface IFileProcessorService {
  processFile(
    inputPath: string,
    options?: FileProcessingOptions,
  ): Promise<FileProcessingResult>;
  validateInputFile(inputPath: string): Promise<boolean>;
  generateOutputPath(inputPath: string, outputDir?: string): Promise<string>;
}

export class FileProcessorService implements IFileProcessorService {
  constructor(
    private readonly logger: ILogger,
    private readonly errorHandler: IErrorHandler,
    private readonly _configManager: IConfigManager, // Reserved for future use, eslint-disable-line @typescript-eslint/no-unused-vars
    private readonly fileSystemManager: IFileSystemManager,
    private readonly markdownParserService: IMarkdownParserService,
    private readonly pdfGeneratorService: IPDFGeneratorService,
    private readonly translator: ITranslationManager,
  ) {
    // _configManager is reserved for future configuration options
    void this._configManager;
  }

  async processFile(
    inputPath: string,
    options: FileProcessingOptions = {},
  ): Promise<FileProcessingResult> {
    const startTime = Date.now();

    try {
      this.logger.info(`Starting file processing: ${inputPath}`);

      // Validate input file
      await this.validateInputFile(inputPath);

      // Generate output path if not provided
      const outputPath =
        options.outputPath || (await this.generateOutputPath(inputPath));

      // Read original markdown content for page estimation
      const originalMarkdownContent = (await this.fileSystemManager.readFile(
        inputPath,
        'utf8',
      )) as string;

      // Parse Markdown content
      this.logger.debug('Parsing Markdown content');
      const parsedContent =
        await this.markdownParserService.parseMarkdownFile(inputPath);

      // All TOC processing is now handled by two-stage rendering
      let finalHtmlContent = parsedContent.content;

      if (options.includeTOC && parsedContent.headings.length > 0) {
        this.logger.debug(
          'TOC will be generated by two-stage rendering engine',
        );
      }

      // Process image paths before PDF generation
      finalHtmlContent = ImagePathResolver.processImagePaths(
        finalHtmlContent,
        inputPath,
      );

      // Apply custom styles if provided
      if (options.customStyles) {
        finalHtmlContent = this.injectStyles(
          finalHtmlContent,
          options.customStyles,
        );
      }

      // Generate anchor links if enabled
      if (
        options.tocReturnLinksLevel &&
        options.tocReturnLinksLevel > 0 &&
        parsedContent.headings.length > 0
      ) {
        this.logger.debug('Adding return-to-TOC anchor links');
        const anchorDepth = this.convertTOCReturnLinkLevelToDepth(
          options.tocReturnLinksLevel,
        );

        const anchorLinksGenerator = new AnchorLinksGenerator(
          {
            enabled: true,
            anchorDepth: anchorDepth,
            linkText: this.translator.t('anchorLinks.backToToc'),
            alignment: 'right',
          },
          this.translator,
        );

        const result = anchorLinksGenerator.insertAnchorLinks(
          finalHtmlContent,
          parsedContent.headings,
          options.includeTOC,
        );

        finalHtmlContent = result.modifiedHtml;

        if (result.linksInserted > 0) {
          this.logger.debug(`Inserted ${result.linksInserted} anchor links`);

          // Add anchor links CSS styles
          const anchorStyles = anchorLinksGenerator.getStyles();
          finalHtmlContent = this.injectStyles(finalHtmlContent, anchorStyles);
        }
      }

      // Generate PDF
      this.logger.debug(`Generating PDF: ${outputPath}`);
      this.logger.debug('File processor received options:', {
        includeTOC: options.includeTOC,
        tocOptions: options.tocOptions,
      });

      // Extract title: prioritize first H1 heading, then metadata title, then default
      const firstH1 = parsedContent.headings.find((h) => h.level === 1);
      const documentTitle =
        firstH1?.text ||
        (parsedContent.metadata?.title as string) ||
        'Markdown Document';

      const pdfResult = await this.pdfGeneratorService.generatePDF(
        finalHtmlContent,
        outputPath,
        {
          ...(options.customStyles && { customCSS: options.customStyles }),
          title: documentTitle,
          headings: parsedContent.headings,
          markdownContent: originalMarkdownContent, // Use original markdown content for page estimation
          enableChineseSupport: true,
          ...(options.includePageNumbers !== undefined && {
            includePageNumbers: options.includePageNumbers,
          }),
          // Pass TOC configuration
          includeTOC: options.includeTOC || false,
          ...(options.includeTOC && {
            tocOptions: {
              enabled: true,
              maxDepth: options.tocOptions?.maxDepth || 3,
              includePageNumbers:
                options.tocOptions?.includePageNumbers !== false,
              ...(options.tocOptions &&
                'title' in options.tocOptions && {
                  title: (options.tocOptions as any).title,
                }),
            },
          }),
          // Enable PDF bookmarks by default when TOC is enabled
          ...(options.includeTOC && {
            bookmarkOptions: {
              enabled: true,
              maxDepth: options.tocOptions?.maxDepth || 3,
              includePageNumbers:
                options.tocOptions?.includePageNumbers !== false,
              useExistingTOC: false,
            },
          }),
        },
      );

      // Get file size
      const fileStats = await this.fileSystemManager.getStats(outputPath);
      const fileSize = fileStats.size;

      const processingTime = Date.now() - startTime;

      const result: FileProcessingResult = {
        inputPath,
        outputPath,
        success: true,
        parsedContent,
        pdfResult,
        processingTime,
        fileSize,
      };

      this.logger.info(
        `File processing completed successfully: ${inputPath} -> ${outputPath} (${processingTime}ms, ${fileSize} bytes)`,
      );

      return result;
    } catch (error) {
      const processingTime = Date.now() - startTime;

      const wrappedError = new MD2PDFError(
        `File processing failed: ${(error as Error).message}`,
        'FILE_PROCESSING_ERROR',
        'file_system',
        true,
        {
          inputPath,
          outputPath: options.outputPath,
          processingTime,
          options,
          originalError: error,
        },
      );

      await this.errorHandler.handleError(
        wrappedError,
        'FileProcessorService.processFile',
      );
      throw wrappedError;
    }
  }

  async validateInputFile(inputPath: string): Promise<boolean> {
    try {
      this.logger.debug(`Validating input file: ${inputPath}`);

      // Check if file exists
      if (!(await this.fileSystemManager.exists(inputPath))) {
        throw new FileNotFoundError(inputPath);
      }

      // Check if it's a markdown file
      const ext = path.extname(inputPath).toLowerCase();
      if (!['.md', '.markdown'].includes(ext)) {
        throw new MD2PDFError(
          `Invalid file extension: ${ext}. Only .md and .markdown files are supported.`,
          'INVALID_FILE_EXTENSION',
          'validation',
          false,
          { inputPath, extension: ext },
        );
      }

      // Check if file is readable
      const stats = await this.fileSystemManager.getStats(inputPath);
      if (!stats.permissions.read) {
        throw new MD2PDFError(
          `File is not readable: ${inputPath}`,
          'FILE_NOT_READABLE',
          'file_system',
          false,
          { inputPath },
        );
      }

      this.logger.info(`Input file validation passed: ${inputPath}`);

      return true;
    } catch (error) {
      if (error instanceof MD2PDFError || error instanceof FileNotFoundError) {
        await this.errorHandler.handleError(
          error,
          'FileProcessorService.validateInputFile',
        );
        throw error;
      }

      const wrappedError = new MD2PDFError(
        `File validation failed: ${(error as Error).message}`,
        'FILE_VALIDATION_ERROR',
        'validation',
        false,
        { inputPath, originalError: error },
      );

      await this.errorHandler.handleError(
        wrappedError,
        'FileProcessorService.validateInputFile',
      );
      throw wrappedError;
    }
  }

  async generateOutputPath(
    inputPath: string,
    outputDir?: string,
  ): Promise<string> {
    try {
      const parsedPath = path.parse(inputPath);
      const outputFileName = `${parsedPath.name}.pdf`;

      let outputPath: string;
      if (outputDir) {
        // Ensure output directory exists
        await this.fileSystemManager.createDirectory(outputDir);
        outputPath = path.join(outputDir, outputFileName);
      } else {
        // Use same directory as input file
        outputPath = path.join(parsedPath.dir, outputFileName);
      }

      this.logger.debug(`Generated output path: ${inputPath} -> ${outputPath}`);

      return outputPath;
    } catch (error) {
      const wrappedError = new MD2PDFError(
        `Failed to generate output path: ${(error as Error).message}`,
        'OUTPUT_PATH_ERROR',
        'file_system',
        false,
        { inputPath, outputDir, originalError: error },
      );

      await this.errorHandler.handleError(
        wrappedError,
        'FileProcessorService.generateOutputPath',
      );
      throw wrappedError;
    }
  }

  /**
   * Convert TOCReturnLinkLevel to AnchorLinksDepth
   */
  private convertTOCReturnLinkLevelToDepth(
    level: TOCReturnLinkLevel,
  ): AnchorLinksDepth {
    switch (level) {
      case 0:
        return 'none';
      case 1:
        return 2; // H2 sections
      case 2:
        return 3; // H2-H3 sections
      case 3:
        return 4; // H2-H4 sections
      case 4:
        return 5; // H2-H5 sections
      case 5:
        return 6; // H2-H6 sections
      default:
        return 'none';
    }
  }

  private injectStyles(htmlContent: string, customStyles: string): string {
    const headMatch = htmlContent.match(/<head[^>]*>/i);
    if (headMatch) {
      const insertPoint =
        htmlContent.indexOf(headMatch[0]) + headMatch[0].length;
      const styleTag = `\n<style>\n${customStyles}\n</style>\n`;
      return (
        htmlContent.slice(0, insertPoint) +
        styleTag +
        htmlContent.slice(insertPoint)
      );
    }

    // If no head tag, wrap content and add styles
    return `<!DOCTYPE html><html><head><style>\n${customStyles}\n</style></head><body>\n${htmlContent}\n</body></html>`;
  }
}
